'''
Created on Feb 15, 2016

__author__ = "Anibal (alimon) Limon"
__copyright__ = "Copyright 2016, Intel Corp."
__credits__ = ["Anibal Limon"]
__license__ = "GPL"
__version__ = "2.0"
__maintainer__ = "Anibal Limon"
__email__ = "anibal.limon@linux.intel.com"
'''

import os
import re

from buildbot.steps.shell import ShellCommand
from buildbot.process.buildstep import LogLineObserver

DEFAULT_SHELL = 'bash'

class ShellCommandCleanEnv(ShellCommand):
    def __init__(self, factory, argdict=None, **kwargs):
        shell = DEFAULT_SHELL
        if 'SHELL' in kwargs:
            shell = kwargs['SHELL']
            del kwargs['SHELL']

        if 'PENV' in kwargs:
            preserve_env = kwargs['PENV']
            del kwargs['PENV']
        else:
            preserve_env = ['HOME', 'PWD', 'PATH',
                            'http_proxy', 'https_proxy',
                            'ftp_proxy', 'no_proxy', 'GIT_PROXY_COMMAND']

        env_command = self._get_env_cleaned_command(shell, preserve_env)
        self.command = "%s \'%s\'" % (env_command, self.command)
        ShellCommand.__init__(self, **kwargs)

    def _get_env_cleaned_command(self, shell, preserve_env):
        pe_cmd = ''
        for pe in preserve_env:
            pe_cmd += "%s=\"$%s\" " % (pe, pe)

        return "env -i %s %s -c " % (pe_cmd, shell)

class BitbakeLogLineObserver(LogLineObserver):
    """
        Search in the stdio bitbake log for exception/errors, identify
        if the error is a recipe/task one if not turn on the flag of
        bitbake error/exception and save the log.
    """

    rexp_error = re.compile("^ERROR: .*$")

    # recipe task errors regex'es
    rexp_pnpv_error = re.compile("^ERROR: (?P<pnpv>.*) do_(?P<task>.*):.*$")
    rexp_task_error = re.compile("^ERROR: Task .*$")
    rexp_log_error = re.compile("^ERROR: Logfile of failure stored in: "\
            "(?P<path>.*)$")

    def _handleError(self, line):
        if not hasattr(self.step, 'errors'):
            self.step.errors = {}
            self.step.errors['bitbake'] = False
            self.step.errors['log'] = []

        # save all the log for be able to get report variables like
        # machine, target, distro, etc
        self.step.errors['log'].append(line)

        # discard line that are not errors and line that
        # is recipe task errors
        if (not self.rexp_error.match(line)) or \
                self.rexp_pnpv_error.match(line) or \
                self.rexp_task_error.match(line) or \
                self.rexp_log_error.match(line):
            return

        # if not match recipe task type is a bitbake exception/error
        self.step.errors['bitbake'] = True

    def outLineReceived(self, line):
        self._handleError(line)

    def errLineReceived(self, line):
        self._handleError(line)

class BitbakeShellCommand(ShellCommand):
    def __init__(self, factory, argdict=None, **kwargs):
        super(BitbakeShellCommand, self).__init__(**kwargs)

        self.stdio_observer = BitbakeLogLineObserver()
        self.addLogObserver('stdio', self.stdio_observer)

    def commandComplete(self, cmd):
        if cmd.didFail():
            pass
