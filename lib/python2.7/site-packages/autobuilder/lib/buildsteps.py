'''
Created on Feb 15, 2016

__author__ = "Anibal (alimon) Limon"
__copyright__ = "Copyright 2016, Intel Corp."
__credits__ = ["Anibal Limon"]
__license__ = "GPL"
__version__ = "2.0"
__maintainer__ = "Anibal Limon"
__email__ = "anibal.limon@linux.intel.com"
'''

import os
import re

import time
import json
import codecs

from buildbot.steps.shell import ShellCommand
from buildbot.process.buildstep import LogLineObserver

from lib.ABTools import get_error_report_controller_dir

DEFAULT_SHELL = 'bash'

class ShellCommandCleanEnv(ShellCommand):
    def __init__(self, factory, argdict=None, **kwargs):
        shell = DEFAULT_SHELL
        if 'SHELL' in kwargs:
            shell = kwargs['SHELL']
            del kwargs['SHELL']

        if 'PENV' in kwargs:
            preserve_env = kwargs['PENV']
            del kwargs['PENV']
        else:
            preserve_env = ['HOME', 'PWD', 'PATH',
                            'http_proxy', 'https_proxy',
                            'ftp_proxy', 'no_proxy', 'GIT_PROXY_COMMAND']

        env_command = self._get_env_cleaned_command(shell, preserve_env)
        self.command = "%s \'%s\'" % (env_command, self.command)
        ShellCommand.__init__(self, **kwargs)

    def _get_env_cleaned_command(self, shell, preserve_env):
        pe_cmd = ''
        for pe in preserve_env:
            pe_cmd += "%s=\"$%s\" " % (pe, pe)

        return "env -i %s %s -c " % (pe_cmd, shell)

class BitbakeLogLineObserver(LogLineObserver):
    """
        Search in the stdio bitbake log for exception/errors, identify
        if the error is a recipe/task one if not turn on the flag of
        bitbake error/exception and save the log.
    """

    rexp_error = re.compile("^ERROR: .*$")

    # recipe task errors regex'es
    rexp_pnpv_error = re.compile("^ERROR: (?P<pnpv>.*) do_(?P<task>.*):.*$")
    rexp_task_error = re.compile("^ERROR: Task .*$")
    rexp_log_error = re.compile("^ERROR: Logfile of failure stored in: "\
            "(?P<path>.*)$")

    def _handleError(self, line):
        if not hasattr(self.step, 'errors'):
            self.step.errors = {}
            self.step.errors['bitbake'] = False
            self.step.errors['log'] = []

        # save all the log for be able to get report variables like
        # machine, target, distro, etc
        self.step.errors['log'].append(line)

        # discard line that are not errors and line that
        # is recipe task errors
        if (not self.rexp_error.match(line)) or \
                self.rexp_pnpv_error.match(line) or \
                self.rexp_task_error.match(line) or \
                self.rexp_log_error.match(line):
            return

        # if not match recipe task type is a bitbake exception/error
        self.step.errors['bitbake'] = True

    def outLineReceived(self, line):
        self._handleError(line)

    def errLineReceived(self, line):
        self._handleError(line)

class BitbakeShellCommand(ShellCommand):
    def __init__(self, factory, argdict=None, **kwargs):
        super(BitbakeShellCommand, self).__init__(**kwargs)

        self.stdio_observer = BitbakeLogLineObserver()
        self.addLogObserver('stdio', self.stdio_observer)

    def _get_variables(self, log):
        vrs = {}

        rexp = re.compile("^(.*)=.*\"(.*)\"$")
        for line in log:
            m = rexp.match(line)
            if m:
                vrs[m.group(1).rstrip()] = m.group(2)

        return vrs

    def _createBitbakeErrorReport(self, log):
        vrs = self._get_variables(log)

        report = {}
        report['machine'] = vrs['MACHINE']
        report['build_sys'] = vrs['BUILD_SYS']
        report['nativelsb'] = vrs['NATIVELSBSTRING']
        report['distro'] = vrs['DISTRO']
        report['target_sys'] = vrs['TARGET_SYS']

        report['component'] = 'bitbake'
        report['branch_commit'] = self.getProperty('branch') + ': ' + \
                self.getProperty('got_revision')

        failure = {}
        failure['package'] = "bitbake-%s" % vrs['BB_VERSION']
        if 'bitbake-selftest' in self.command:
            report['error_type'] = 'B'
            failure['task'] = self.command[self.command.find('bitbake-selftest'):]
        else:
            report['error_type'] = 'C'
            failure['task'] = self.command[self.command.find('bitbake'):]

        failure['log'] = "\n".join(log)

        report['failures'] = [failure]

        return report

    def _saveBitbakeErrorReport(self, report):
        buildername = self.getProperty('buildername')
        buildnumber = self.getProperty('buildnumber')

        errordir = get_error_report_controller_dir(buildername, buildnumber)
        if not os.path.exists(errordir):
            os.makedirs(errordir)

        filename = os.path.join(errordir, "error_report_bitbake_%d.txt" % \
                int(time.time()))
        with codecs.open(filename, 'w', 'utf-8') as f:
            json.dump(report, f, indent=4, sort_keys=True)

    def commandComplete(self, cmd):
        if cmd.didFail():
            if self.errors['bitbake']:
                report = self._createBitbakeErrorReport(self.errors['log'])
                self._saveBitbakeErrorReport(report)
