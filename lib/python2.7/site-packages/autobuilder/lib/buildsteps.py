'''
Created on Feb 15, 2016

__author__ = "Anibal (alimon) Limon"
__copyright__ = "Copyright 2016, Intel Corp."
__credits__ = ["Anibal Limon"]
__license__ = "GPL"
__version__ = "2.0"
__maintainer__ = "Anibal Limon"
__email__ = "anibal.limon@linux.intel.com"
'''

import os
import re


from buildbot.steps.shell import ShellCommand
from buildbot.process.buildstep import LogLineObserver

from lib.ABTools import save_error_report

DEFAULT_SHELL = 'bash'

class ShellCommandCleanEnv(ShellCommand):
    def __init__(self, factory, argdict=None, **kwargs):
        shell = DEFAULT_SHELL
        if 'SHELL' in kwargs:
            shell = kwargs['SHELL']
            del kwargs['SHELL']

        if 'PENV' in kwargs:
            preserve_env = kwargs['PENV']
            del kwargs['PENV']
        else:
            preserve_env = ['HOME', 'PWD', 'PATH',
                            'http_proxy', 'https_proxy',
                            'ftp_proxy', 'no_proxy', 'GIT_PROXY_COMMAND']

        env_command = self._get_env_cleaned_command(shell, preserve_env)
        self.command = "%s \'%s\'" % (env_command, self.command)
        ShellCommand.__init__(self, **kwargs)

    def _get_env_cleaned_command(self, shell, preserve_env):
        pe_cmd = ''
        for pe in preserve_env:
            pe_cmd += "%s=\"$%s\" " % (pe, pe)

        return "env -i %s %s -c " % (pe_cmd, shell)

class BitbakeLogLineObserver(LogLineObserver):
    """
        Search in the stdio bitbake log for exception/errors, identify
        if the error is a recipe/task one if not turn on the flag of
        bitbake error/exception and save the log.
    """

    rexp_error = re.compile("^ERROR: .*$")

    # recipe task errors regex'es
    rexp_pnpv_error = re.compile("^ERROR: (?P<pnpv>.*) do_(?P<task>.*):.*$")
    rexp_task_error = re.compile("^ERROR: Task .*$")
    rexp_log_error = re.compile("^ERROR: Logfile of failure stored in: "\
            "(?P<path>.*)$")

    def _handleError(self, line):
        if not hasattr(self.step, 'errors'):
            self.step.errors = {}
            self.step.errors['bitbake'] = False
            self.step.errors['log'] = []

        # save all the log for be able to get report variables like
        # machine, target, distro, etc
        self.step.errors['log'].append(line)

        # discard line that are not errors and line that
        # is recipe task errors
        if (not self.rexp_error.match(line)) or \
                self.rexp_pnpv_error.match(line) or \
                self.rexp_task_error.match(line) or \
                self.rexp_log_error.match(line):
            return

        # if not match recipe task type is a bitbake exception/error
        self.step.errors['bitbake'] = True

    def outLineReceived(self, line):
        self._handleError(line)

    def errLineReceived(self, line):
        self._handleError(line)

class BitbakeShellCommand(ShellCommand):
    def __init__(self, factory, argdict=None, **kwargs):
        super(BitbakeShellCommand, self).__init__(**kwargs)

        self.stdio_observer = BitbakeLogLineObserver()
        self.addLogObserver('stdio', self.stdio_observer)

    def _get_variables(self, log):
        vrs = {}

        rexp = re.compile("^(.*)=.*\"(.*)\"$")
        for line in log:
            m = rexp.match(line)
            if m:
                vrs[m.group(1).rstrip()] = m.group(2)

        return vrs

    def _get_variable_safe(self, vrs, name):
        if name in vrs:
            return vrs[name]
        else:
            return 'unknown_{0}'.format(name)

    def _createBitbakeErrorReport(self, log):
        vrs = self._get_variables(log)

        report = {}
        report['machine'] = self._get_variable_safe(vrs, 'MACHINE')
        report['build_sys'] = self._get_variable_safe(vrs, 'BUILD_SYS')
        report['nativelsb'] = self._get_variable_safe(vrs, 'NATIVELSBSTRING')
        report['distro'] = self._get_variable_safe(vrs, 'DISTRO')
        report['target_sys'] = self._get_variable_safe(vrs, 'TARGET_SYS')

        report['component'] = 'bitbake'
        try:
            branch = self.getProperty('branch')
            revision = self.getProperty('got_revision')
            if not revision:
                revision = self.getProperty('got_revision_oecore')
        except:
            branch = "unknown_branch"
            revision = "unknown_revision"
        report['branch_commit'] = branch + ': ' + revision

        failure = {}
        failure['package'] = "bitbake-%s" % self._get_variable_safe(vrs, 'BB_VERSION')
        if 'bitbake-selftest' in self.command:
            report['error_type'] = 'bitbake-selftest'
            failure['task'] = self.command[self.command.find('bitbake-selftest'):]
        else:
            report['error_type'] = 'core'
            failure['task'] = self.command[self.command.find('bitbake'):]

        failure['log'] = "\n".join(log)

        report['failures'] = [failure]

        return report

    def commandComplete(self, cmd):
        if cmd.didFail():
            if self.errors['bitbake']:
                buildername = self.getProperty('buildername')
                buildnumber = self.getProperty('buildnumber')

                report = self._createBitbakeErrorReport(self.errors['log'])
                save_error_report(buildername, buildnumber, report, 'bitbake')
